package no.mil.fnse.service;

import java.io.IOException;
import java.net.DatagramPacket;

import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import no.mil.fnse.model.Controller;
import no.mil.fnse.model.Peer;
import no.mil.fnse.configuration.DiscoveryConfiguration;

@EnableScheduling
@Service
public class DiscoveryServiceImpl implements DiscoveryService {
	final int HELLO_INTERVAL = 30;
	boolean listenToHelloStarted = false;
    byte[] buf = new byte[256];

	/**
	 * Sends a HELLO message every HELLO_INTERVAL
	 */
	@Scheduled(initialDelay=5*1000,fixedRate=30000)
	public void sendHello() {
		System.out.println("Trying to send HELLO");
        try {
			DiscoveryConfiguration.SERVER_SOCKET.send(DiscoveryConfiguration.HELLO_PACKET);
			System.out.println("HELLO Sent");
		} catch (IOException e) {
			e.printStackTrace();
		}		
	}

	/**
	 * DET ER ET PROBLEM AT DENNE STOPPER OPP ALLE TRÅDER NÅR DEN KJØRER 
	 * WE NEED TO HAVE A SEPARATE SOCKET FOR THIS. WE ALSO NEED TO REGULARY SEND IGMP JOIN MESSAGES...
	 */
	@Scheduled(initialDelay=4*1000, fixedDelay = 1)
	public void listenHello() {
		System.out.println("Setting up listener port");
//		if(!listenToHelloStarted){

//            while (true) {
                // Receive the information and print it.
                DatagramPacket msgPacket = new DatagramPacket(buf, buf.length);
                try {
					DiscoveryConfiguration.CLIENT_SOCKET.receive(msgPacket);
	                String msg = new String(buf, 0, buf.length);
	                ObjectMapper mapper = new ObjectMapper();
	                Controller ctrl;
				
					ctrl = mapper.readValue(msg, Controller.class);
			
	                Peer neighbor = new Peer();
	                neighbor.setRemoteInterfaceIp( msgPacket.getAddress());
	                //REMEMBER TO CHANGE THIS!!  /// We have to find the intermediate interfaces
	                neighbor.setLocalInterfaceIp(null);
	                neighbor.setController(ctrl);
	//                if(isDiscovered(neighbor)){
	//                	//updateTimeStamp(neighbor);
	//                	System.out.print("Is already discovered: ");
	//                	
	//                }else{
	//                	neighbor.setStatus(PeerStatus.DISCOVERED);
	//                	discoveredNeighbors.add(neighbor.getRemoteInterfaceIp());
	//                	System.out.print("Neew peer: ");
	//                	
	//                }
	                System.out.println("Discovered:"+ctrl.getEntityId() + ctrl.getIpAddress() + neighbor.getRemoteInterfaceIp() );
//	                listenToHelloStarted = true;
				} catch (JsonParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (JsonMappingException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
//            }
            
			
			
//		}
                System.out.println("EXIT LISTENER");
		
	}
	
	public void checkDeadPeer() {
		// TODO Auto-generated method stub
		/*
		 * Check database where current date time > timestamp and not marked as DEAD
		 * 
		 */
		
		
	}



}
